"""백준 2617 구슬 찾기"""
"""문제
모양 같고, 무게 다른 n개 구슬 (n은 홀수)
구슬 번호 1, 2, ... n으로 붙어있음
무게가 전체의 중산인 (n + 1) / 2 번째 구슬을 찾기 위해 아래 일을 함
양팔 저울
m개의 쌍을 골라서 각각 양파 저울에 올려 어느 것이 묵운가 알아냄
이 결과를 이용하여 무게가 중간이 될 가능성이 전혀 없는 구슬들은 먼저 제외한다.

m개의 쌍을 골라서 어느 것이 무거운가 알아냄
이 결과ㅣ를 이용하여 무게가 중간이 될 가능서이 전혀 없는 구슬들은 먼저 제외

n = 5, m = 4
1. 2번 > 1번
2. 4번 > 3번
3. 5번 > 1번
4. 4번 > 2번

--> 2 > 1 
    5 > 1
    4 > 2 > 1
    4 > 3
    --> 1번 4번은 절대 무게가 중간인 구술이 될 수 없다.

n : 구슬의 개수 ( 1 <= n <= 99 )
m : 저울에 올려 본 쌍의 개수 ( 1 <= m <= n(n-1)/2 )
앞 번호의 구슬이 뒷 구슬보다 무겁다
"""
"""문제 접근 방법
현재 구슬보다 큰 구슬의 개수가 (n+1)//2 개 이상이거나
작은 구슬의 개수가 **(n+1)//2 개 이상**이라면  그 구슬은 **절대 중간값이 될 수 없다**.

현재 구슬보다 큰 구슬에 대한 연결 그래프와 
현재 구슬보다 작은 구슬에 대한 연결 그래프를 각각 만든다.

1번 구슬부터 ~ n번째 구슬까지 각각
큰 연결 그래프(1)과 작은 연결 그래프(2)에 대해
bfs를 이용하여 탐색하면서 
현재 노드가 (n+1)//2 개 보다 많은 연결 관계를 가지고 있다면 
정답 개수 (`answer`) + 1 해준다.

포인트 : 
- 현재 노드보다 큰 구슬 연결 정보를 가지는 그래프(1)와 작은 구슬 연결 정보를 가지는 그래프(2), 총 2개의 그래프를 생성 후 탐색해야 한다.
- 구슬의 중간 위치의 중간 (구슬의 개수 + 1) // 2 을 넘어가면 그 구슬은 절대 중간에 있을 수 없다. 
"""

import sys
from collections import deque

# n : 구슬의 개수 ( 1 <= n <= 99 )
# m : 저울에 올려 본 쌍의 개수 ( 1 <= m <= n(n-1)/2 )
n, m = map(int, sys.stdin.readline().split())

# 구슬 연결 정보
more = [ [] for _ in range(n + 1)]
less = [ [] for _ in range(n + 1)]

# 정답 배열 및 중간 위치 기준 변수 선언
answer = 0
mid = (n + 1) // 2

# 구슬 연결 정보 입력받아서 2개의 그래프에 각각 저장
for _ in range(m):
    a, b = map(int, sys.stdin.readline().split())
    more[a].append(b)
    less[b].append(a)

# BFS 
def bfs(data, x):
    global count
    # 탐색 시작 노드 방문처리 후 큐에 삽입
    queue = deque([x])
    visited[x] = True

    while queue:
        v = queue.popleft()

        # 인접 노드 중에서 방문하지 않은 노드의 갯수를 세고 방문처리 후 큐에 삽입
        for i in data[v]:
            if not visited[i]:
                visited[i] = True
                queue.append(i)
                count = count + 1

# 1번째 구슬부터 n번째 구슬까지 큰 연결 그래프(1)와 작은 연결 그래프를 탐색하여
# 연결된 노드의 개수를 구한다.
# 연결된 노드의 개수가 중간이 될 수 있는 기준 값인 (`(n+1)//2`) 보다 크다면
# 정답 변수(`answer`)에 +1 을 한다.
for i in range(1, n + 1):
    visited = [False] * (n + 1)
    
    count = 0
    bfs(more, i)
    if count >= mid:
        answer += 1

    count = 0
    bfs(less, i)
    if count >= mid:
        answer += 1

print(answer)